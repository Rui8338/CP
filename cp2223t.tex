\documentclass[a4paper]{article}
\usepackage[a4paper,left=3cm,right=2cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[sfdefault, book, lf]{FiraSans} % lf - lined numbers
\usepackage[colorlinks=true]{hyperref}
\usepackage{graphicx}
\usepackage{cp2223t}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage[indent=12pt]{parskip}

%================= lhs2tex=====================================================%
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
\def\plus{\mathbin{\dagger}}
\def\kcomp{\mathbin{\bullet}}
%---------------------------------------------------------------------------

\title{
          \textbf{Cálculo de Programas}
\\
          Trabalho Prático
\\
          LEI --- 2022/23
}

\author{
          \dium
\\
          Universidade do Minho
}


\date\mydate

\makeindex
\newcommand{\rn}[1]{\textcolor{Red}{#1}}
\begin{document}
\emergencystretch 3em
%\sloppy

\maketitle

\begin{center}\large
\begin{tabular}{ll}
\textbf{Grupo} nr. & 31
\\\hline
a97133 & Rui Silva
\\
a96267 & Hugo Novais
\\
a97018 & Telmo Oliveira
\end{tabular}
\end{center}

\section*{Preâmbulo}

\CP\ tem como objectivo principal ensinar
a progra\-mação de computadores como uma disciplina científica. Para isso
parte-se de um repertório de \emph{combinadores} que formam uma álgebra da
programação (conjunto de leis universais e seus corolários) e usam-se esses
combinadores para construir programas \emph{composicionalmente}, isto é,
agregando programas já existentes.

Na sequência pedagógica dos planos de estudo dos cursos que têm
esta disciplina, opta-se pela aplicação deste método à programação
em \Haskell\ (sem prejuízo da sua aplicação a outras linguagens
funcionais). Assim, o presente trabalho prático coloca os
alunos perante problemas concretos que deverão ser implementados em
\Haskell.  Há ainda um outro objectivo: o de ensinar a documentar
programas, a validá-los e a produzir textos técnico-científicos de
qualidade.

Antes de abodarem os problemas propostos no trabalho, os grupos devem ler
com atenção o anexo \ref{sec:documentacao} onde encontrarão as instruções
relativas ao sofware a instalar, etc.


\Problema
Suponha-se uma sequência numérica semelhante à sequência de Fibonacci tal
que cada termo subsequente aos três primeiros corresponde à soma dos três
anteriores, sujeitos aos coeficientes \ensuremath{\Varid{a}}, \ensuremath{\Varid{b}} e \ensuremath{\Varid{c}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\mathrm{0}\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}\Varid{f}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\mathrm{1}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{f}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\mathrm{2}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{f}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;(\Varid{n}\mathbin{+}\mathrm{3})\mathrel{=}\Varid{a}\mathbin{*}\Varid{f}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;(\Varid{n}\mathbin{+}\mathrm{2})\mathbin{+}\Varid{b}\mathbin{*}\Varid{f}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathbin{+}\Varid{c}\mathbin{*}\Varid{f}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Assim, por exemplo, \ensuremath{\Varid{f}\;\mathrm{1}\;\mathrm{1}\;\mathrm{1}} irá dar como resultado a sequência:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathrm{1},\mathrm{1},\mathrm{2},\mathrm{4},\mathrm{7},\mathrm{13},\mathrm{24},\mathrm{44},\mathrm{81},\mathrm{149},\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\ensuremath{\Varid{f}\;\mathrm{1}\;\mathrm{2}\;\mathrm{3}} irá gerar a sequência:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathrm{1},\mathrm{1},\mathrm{3},\mathrm{8},\mathrm{17},\mathrm{42},\mathrm{100},\mathrm{235},\mathrm{561},\mathrm{1331},\mathbin{...}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
etc.

A definição de \ensuremath{\Varid{f}} dada é muito ineficiente, tendo uma degradação do tempo
de execução exponencial.
Pretende-se otimizar a função dada convertendo-a para um ciclo \textit{for}.
Recorrendo à lei de recursividade mútua, calcule \ensuremath{\Varid{loop}} e \ensuremath{\Varid{initial}} em
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fbl}\;\Varid{a}\;\Varid{b}\;\Varid{c}\mathrel{=}\Varid{wrap}\comp \for{(\Varid{loop}\;\Varid{a}\;\Varid{b}\;\Varid{c})}\ {\Varid{initial}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
por forma a \ensuremath{\Varid{f}} e \ensuremath{\Varid{fbl}} serem (matematicamente) a mesma função. 
Para tal, poderá usar a regra prática explicada no anexo \ref{sec:mr}.

\textbf{Valorização}: apresente testes de \textit{performance} que mostrem
quão mais rápida é \ensuremath{\Varid{fbl}} quando comparada com \ensuremath{\Varid{f}}.

\Problema
Pretende-se vir a classificar os conteúdos programáticos de todas as
\href{https://web.di.uminho.pt/sitedi/ucs/}{UCs} lecionadas no \dium\ de
acordo com o \href{https://dl.acm.org/ccs}{ACM Computing Classification System}.
A listagem da taxonomia desse sistema está disponível no ficheiro
\texttt{Cp2223data}, 
começando com
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{acm\char95 ccs}\mathrel{=}[\mskip1.5mu {}\<[14]%
\>[14]{}\text{\ttfamily \char34 CCS\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~General~and~reference\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~~~~~Document~types\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~~~~~~~~~Surveys~and~overviews\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~~~~~~~~~Reference~works\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~~~~~~~~~General~conference~proceedings\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~~~~~~~~~Biographies\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~~~~~~~~~General~literature\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~~~~~~~~~Computing~standards,~RFCs~and~guidelines\char34},{}\<[E]%
\\
\>[14]{}\text{\ttfamily \char34 ~~~~~~~~Cross-computing~tools~and~techniques\char34},{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
(10 primeiros ítens) etc., etc.\footnote{Informação obtida a partir do site
\href{https://dl.acm.org/ccs}{ACM CCS} selecionando \emph{Flat View}.}

Pretende-se representar a mesma informação sob a forma de uma árvore de expressão,
usando para isso a biblioteca \Exp\ que consta do material padagógico da disciplina e
que vai incluída no zip do projecto, por  ser mais conveniente para os alunos.

\begin{enumerate}
\item Comece por definir a função de conversão do texto dado em \ensuremath{\Varid{acm\char95 ccs}}
(uma lista de \emph{strings}) para uma tal árvore como um anamorfismo de \Exp:
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tax}\mathbin{::}[\mskip1.5mu \Conid{String}\mskip1.5mu]\to \Conid{Exp}\;\Conid{String}\;\Conid{String}{}\<[E]%
\\
\>[B]{}\Varid{tax}\mathrel{=}\lanabracket\;\!\Varid{gene}\;\!\ranabracket_\textit{\tiny Exp}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Ou seja, defina o \ensuremath{\Varid{gene}} do anamorfismo, 
tendo em conta o seguinte diagrama\footnote{\ensuremath{\Conid{S}} abrevia \ensuremath{\Conid{String}}.}:
\begin{eqnarray*}
\xymatrix{
  \ensuremath{\Conid{Exp}\;\Conid{S}\;\Conid{S}} & & S + S \times (\ensuremath{\Conid{Exp}\;\Conid{S}\;\Conid{S}})^*\ar[ll]_{\ensuremath{\mathsf{in}_{\tiny\ \textit{Exp}}}} \\
  S^*\ar@/_1.5pc/[rr]_{\ensuremath{\Varid{gene}}}\ar[r]^(0.35){\ensuremath{\Varid{out}}}\ar[u]^{\ensuremath{\Varid{tax}}} & S + S \times S^*\ar[r]^(0.45){\cdots} & S + S \times (S^*)^*\ar[u]_{id + id \times tax^*}
}
\end{eqnarray*}
Para isso, tome em atenção que cada nível da hierarquia é, em \ensuremath{\Varid{acm\char95 ccs}},
marcado pela indentação de 4 espaços adicionais --- como se mostra no fragmento acima.

Na figura \ref{fig:P1} mostra-se a representação gráfica da árvore de tipo \Exp\ que representa o fragmento de \ensuremath{\Varid{acm\char95 ccs}} mostrado acima.

\begin{figure}[ht!]
\centering
\begin{tikzpicture}
[-,every node/.style={shape=rectangle,inner sep=3pt,draw}]
\footnotesize
\node {CSS} [edge from parent fork down]
  [sibling distance=4cm]
  child {node [align=center] {General and\\reference}
    [sibling distance=4cm]
    child {node {Document types}
      [sibling distance=2.25cm]
      child {node [align=center] {Surveys and\\overviews}}
      child {node [align=center] {Reference\\works}}
      child {node [align=center] {General\\conference\\proceedings}}
      child {node [align=center] {Biographies}}
      child {node [align=center] {General\\literature}}
      child {node [align=center, xshift=0.75cm] {Computing standards,\\RFCs and\\guidelines}}
    }
    child {node [align=center] {Cross-computing tools and\\techniques}}
  }
  ;
\end{tikzpicture}
\caption{Fragmento de \ensuremath{\Varid{acm\char95 ccs}} representado sob a forma de uma árvore do tipo \Exp.}
\label{fig:P1}
\end{figure}

\item De seguida vamos querer todos os caminhos da árvore que é gerada por \ensuremath{\Varid{tax}},
pois a classificação de uma UC pode ser feita a qualquer nível (isto é, caminho
descendente da raiz \ensuremath{\text{\ttfamily \char34 CCS\char34}} até um subnível ou folha).
\footnote{Para um exemplo de classificação de UC concreto, pf.\  ver a secção \textbf{Classificação ACM} na página
pública de \CP.}

Precisamos pois da composição de \ensuremath{\Varid{tax}} com uma função de pós-processamento \ensuremath{\Varid{post}},
%
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{tudo}\mathbin{::}[\mskip1.5mu \Conid{String}\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Conid{String}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{tudo}\mathrel{=}\Varid{post}\comp \Varid{tax}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
para obter o efeito que se mostra na tabela \ref{table:acmccs}.

\begin{table}[ht!]
\centering\small
\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
CCS & & & 
\\\hline
CCS & General and reference & & 
\\\hline
CCS & General and reference & Document types & 
\\\hline
CCS & General and reference & Document types & Surveys and overviews
\\\hline
CCS & General and reference & Document types & Reference works
\\\hline
CCS & General and reference & Document types & General conference proceedings
\\\hline
CCS & General and reference & Document types & Biographies
\\\hline
CCS & General and reference & Document types & General literature
\\\hline
CCS & General and reference & Cross-computing tools and techniques & 
\\\hline
\end{tabular}
\end{center}
\caption{Taxonomia ACM fechada por prefixos (10 primeiros ítens).}
\label{table:acmccs}
\end{table}

Defina a função \ensuremath{\Varid{post}\mathbin{::}\Conid{Exp}\;\Conid{String}\;\Conid{String}\to [\mskip1.5mu [\mskip1.5mu \Conid{String}\mskip1.5mu]\mskip1.5mu]} da forma mais económica que encontrar.
\end{enumerate}

\textbf{Sugestão}: Inspecione as bibliotecas fornecidas à procura de funções
auxiliares que possa re-utilizar para a sua solução ficar mais simples.
Não se esqueça que, para o mesmo resultado,
nesta disciplina \emph{``ganha'' quem escrever menos código}!

\textbf{Sugestão}: Para efeitos de testes intermédios não use a totalidade de \ensuremath{\Varid{acm\char95 ccs}},
que tem 2114 linhas! Use, por exemplo, \ensuremath{\Varid{take}\;\mathrm{10}\;\Varid{acm\char95 ccs}}, como se mostrou acima.

\Problema

O \sierpCarpet{tapete de Sierpinski} é uma figura geométrica \fractal\ em que um quadrado é subdividido recursivamente em sub-quadrados. A construção clássica do tapete de Sierpinski é a seguinte: assumindo um quadrado de lado \ensuremath{\Varid{l}}, este é subdivido em 9 quadrados iguais de lado \ensuremath{\Varid{l}\mathbin{/}\mathrm{3}}, removendo-se o quadrado central. Este passo é depois repetido sucessivamente para cada um dos 8 sub-quadrados restantes (Fig.~\ref{fig:sierp1}).

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.19\textwidth]{cp2223t_media/tapete1.png}
  \includegraphics[width=0.19\textwidth]{cp2223t_media/tapete2.png}
  \includegraphics[width=0.19\textwidth]{cp2223t_media/tapete3.png}
  \includegraphics[width=0.19\textwidth]{cp2223t_media/tapete4.png}
  \includegraphics[width=0.19\textwidth]{cp2223t_media/tapete5.png}
  \caption{Construção do tapete de Sierpinski com profundidade 5.}
  \label{fig:sierp1}
\end{figure}

\noindent
\ensuremath{\textbf{NB}}: No exemplo da fig.~\ref{fig:sierp1}, assumindo a construção clássica já referida, os quadrados estão a branco e o fundo a verde.

A complexidade deste algoritmo, em função do número de quadrados a desenhar, para uma profundidade $n$, é de $8^n$ (exponencial). No entanto, se assumirmos que os quadrados a desenhar são os que estão a verde, a complexidade é reduzida para $\sum_{i=0}^{n-1}8^i$, obtendo um ganho de $\sum_{i=1}^{n} \frac{100}{8^i} \%$. Por exemplo, para $n=5$, o ganho é de $14.28 \%$. O objetivo deste problema é a implementação do algoritmo mediante a referida otimização.
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.35\textwidth]{cp2223t_media/tapete_ex}
  \caption{Tapete de Sierpinski com profundidade 2 e com os quadrados enumerados.}
  \label{fig:sierp2}
\end{figure}

Assim, seja cada quadrado descrito geometricamente pelas coordenadas do seu vértice inferior esquerdo e o comprimento do seu lado:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Square}\mathrel{=}(\Conid{Point},\Conid{Side}){}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Side}\mathrel{=}\Conid{Double}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Point}\mathrel{=}(\Conid{Double},\Conid{Double}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A estrutura recursiva de suporte à construção de tapetes de Sierpinski será uma \Rose, na qual cada nível da árvore irá guardar os quadrados de tamanho igual. Por exemplo, a construção da fig.~\ref{fig:sierp2} poderá\footnote{A ordem dos filhos não é relevante.} corresponder à árvore da figura \ref{fig:roseTreeSierp}.
\begin{figure}[ht!]
\centering
\begin{tikzpicture}
[level distance = 2cm,
level 1/.style = {sibling distance = 1.5cm},
level 2/.style = {sibling distance = 0.9cm},
]\node [draw, circle]{1}
child {node [draw, circle]{2}
child {node [draw, circle]{10}}
child {node [draw, circle]{11}}
child {node [draw, circle]{12}}
child {node [draw, circle]{13}}
child {node [draw, circle]{14}}
child {node [draw, circle]{15}}
child {node [draw, circle]{16}}
child {node [draw, circle]{17}}}
child {node [draw, circle]{3}}
child {node [draw, circle]{4}}
child {node [draw, circle]{5}}
child {node [draw, circle]{6}}
child {node [draw, circle]{7}}
child {node [draw, circle]{8}}
child {node [draw, circle]{9}};
\end{tikzpicture}
\caption{Possível árvore de suporte para a construção da fig.~\ref{fig:sierp2}.}
\label{fig:roseTreeSierp}
\end{figure}

Uma vez que o tapete é também um quadrado, o objetivo será, a partir das informações do tapete (coordenadas do vértice inferior esquerdo e comprimento do lado), desenhar o quadrado central, subdividir o tapete nos 8 sub-tapetes restantes, e voltar a desenhar, recursivamente, o quadrado nesses 8 sub-tapetes. Desta forma, cada tapete determina o seu quadrado e os seus 8 sub-tapetes. No exemplo em cima, o tapete que contém o quadrado 1 determina esse próprio quadrado e determina os sub-tapetes que contêm os quadrados 2 a 9.

Portanto, numa primeira fase, dadas as informações do tapete, é construida a árvore de suporte com todos os quadrados a desenhar, para uma determinada profundidade.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{squares}\mathbin{::}(\Conid{Square},\Conid{Int})\to \Conid{Rose}\;\Conid{Square}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\ensuremath{\textbf{NB}}: No programa, a profundidade começa em $0$ e não em $1$.

Uma vez gerada a árvore com todos os quadrados a desenhar, é necessário extrair os quadrados para uma lista, a qual é processada pela função \ensuremath{\Varid{drawSq}}, disponibilizada no anexo \ref{sec:codigo}.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{rose2List}\mathbin{::}\Conid{Rose}\;\Varid{a}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Assim, a construção de tapetes de Sierpinski é dada por um hilomorfismo de \textit{Rose Trees}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sierpinski}\mathbin{::}(\Conid{Square},\Conid{Int})\to [\mskip1.5mu \Conid{Square}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{sierpinski}\mathrel{=}\llbracket\, \Varid{gr2l},\,{}\<[29]%
\>[29]{}\Varid{gsq}\,\rrbracket_\textit{\tiny R}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\textbf{Trabalho a fazer:}
\begin{enumerate}
    \item Definir os genes do hilomorfismo \ensuremath{\Varid{sierpinski}}.
    \item Correr
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{sierp4}\mathrel{=}\Varid{drawSq}\;(\Varid{sierpinski}\;(((\mathrm{0},\mathrm{0}),\mathrm{32}),\mathrm{3})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{constructSierp5}\mathrel{=}\mathbf{do}\;\Varid{drawSq}\;(\Varid{sierpinski}\;(((\mathrm{0},\mathrm{0}),\mathrm{32}),\mathrm{0})){}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{await}{}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{drawSq}\;(\Varid{sierpinski}\;(((\mathrm{0},\mathrm{0}),\mathrm{32}),\mathrm{1})){}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{await}{}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{drawSq}\;(\Varid{sierpinski}\;(((\mathrm{0},\mathrm{0}),\mathrm{32}),\mathrm{2})){}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{await}{}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{drawSq}\;(\Varid{sierpinski}\;(((\mathrm{0},\mathrm{0}),\mathrm{32}),\mathrm{3})){}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{await}{}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{drawSq}\;(\Varid{sierpinski}\;(((\mathrm{0},\mathrm{0}),\mathrm{32}),\mathrm{4})){}\<[E]%
\\
\>[B]{}\hsindent{22}{}\<[22]%
\>[22]{}\Varid{await}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
     \item Definir a função que apresenta a construção do tapete de Sierpinski como é apresentada em \ensuremath{\Varid{construcaoSierp5}}, mas para uma profundidade $n \in \mathbb{N}$ recebida como parâmetro.
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{constructSierp}\mathbin{::}\Conid{Int}\to \fun{IO}\;[\mskip1.5mu ()\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{constructSierp}\mathrel{=}\Varid{present}\comp \Varid{carpets}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\textbf{Dica}: a função \ensuremath{\Varid{constructSierp}} será um hilomorfismo de listas, cujo anamorfismo \ensuremath{\Varid{carpets}\mathbin{::}\Conid{Int}\to [\mskip1.5mu [\mskip1.5mu \Conid{Square}\mskip1.5mu]\mskip1.5mu]} constrói, recebendo como parâmetro a profundidade $n$, a lista com todos os tapetes de profundidade $1..n$, e o catamorfismo \ensuremath{\Varid{present}\mathbin{::}[\mskip1.5mu [\mskip1.5mu \Conid{Square}\mskip1.5mu]\mskip1.5mu]\to \fun{IO}\;[\mskip1.5mu ()\mskip1.5mu]} percorre a lista desenhando os tapetes e esperando 1 segundo de intervalo.
\end{enumerate}

\Problema

Este ano ocorrerá a vigésima segunda edição do Campeonato do Mundo de Futebol, organizado pela Federação Internacional de Futebol (FIFA), a decorrer no Qatar e com o jogo inaugural a 20 de Novembro.

Uma casa de apostas pretende calcular, com base numa aproximação dos \textit{rankings}\footnote{Os \textit{rankings} obtidos \href{https://www.fifa.com/fifa-world-ranking/men?dateId=id13687}{aqui} foram escalados e arredondados.} das seleções, a probabilidade de cada seleção vencer a competição.

Para isso, o diretor da casa de apostas contratou o Departamento de Informática da Universidade do Minho, que atribuiu o projeto à equipa formada pelos alunos e pelos docentes de Cálculo de Programas.

\begin{alert}
Para resolver este problema de forma simples, ele será abordado por duas fases:
\begin{enumerate}
\item versão académica sem probabilidades, em que se sabe à partida, num jogo, quem o vai vencer;
\item versão realista com probabilidades usando o mónade \textit{Dist} (distribuições probabilísticas) que vem descrito no anexo \ref{sec:probabilities}.
\end{enumerate}
A primeira versão, mais simples, deverá ajudar a construir a segunda.
\end{alert}

\subsection*{Descrição do problema}

Uma vez garantida a qualificação (já ocorrida), o campeonato consta de duas fases consecutivas no tempo:
\begin{enumerate}
\item fase de grupos;
\item fase eliminatória (ou ``mata-mata'', como é habitual dizer-se no Brasil).
\end{enumerate}

Para a fase de grupos, é feito um sorteio das 32 seleções (o qual já ocorreu para esta competição)
que as coloca em 8 grupos, 4 seleções em cada grupo.
Assim, cada grupo é uma lista de seleções.

Os grupos para o campeonato deste ano são:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Team}\mathrel{=}\Conid{String}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Group}\mathrel{=}[\mskip1.5mu \Conid{Team}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{groups}\mathbin{::}[\mskip1.5mu \Conid{Group}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{groups}\mathrel{=}[\mskip1.5mu [\mskip1.5mu \text{\ttfamily \char34 Qatar\char34},\text{\ttfamily \char34 Ecuador\char34},\text{\ttfamily \char34 Senegal\char34},\text{\ttfamily \char34 Netherlands\char34}\mskip1.5mu],{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}[\mskip1.5mu \text{\ttfamily \char34 England\char34},\text{\ttfamily \char34 Iran\char34},\text{\ttfamily \char34 USA\char34},\text{\ttfamily \char34 Wales\char34}\mskip1.5mu],{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}[\mskip1.5mu \text{\ttfamily \char34 Argentina\char34},\text{\ttfamily \char34 Saudi~Arabia\char34},\text{\ttfamily \char34 Mexico\char34},\text{\ttfamily \char34 Poland\char34}\mskip1.5mu],{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}[\mskip1.5mu \text{\ttfamily \char34 France\char34},\text{\ttfamily \char34 Denmark\char34},\text{\ttfamily \char34 Tunisia\char34},\text{\ttfamily \char34 Australia\char34}\mskip1.5mu],{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}[\mskip1.5mu \text{\ttfamily \char34 Spain\char34},\text{\ttfamily \char34 Germany\char34},\text{\ttfamily \char34 Japan\char34},\text{\ttfamily \char34 Costa~Rica\char34}\mskip1.5mu],{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}[\mskip1.5mu \text{\ttfamily \char34 Belgium\char34},\text{\ttfamily \char34 Canada\char34},\text{\ttfamily \char34 Morocco\char34},\text{\ttfamily \char34 Croatia\char34}\mskip1.5mu],{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}[\mskip1.5mu \text{\ttfamily \char34 Brazil\char34},\text{\ttfamily \char34 Serbia\char34},\text{\ttfamily \char34 Switzerland\char34},\text{\ttfamily \char34 Cameroon\char34}\mskip1.5mu],{}\<[E]%
\\
\>[B]{}\hsindent{11}{}\<[11]%
\>[11]{}[\mskip1.5mu \text{\ttfamily \char34 Portugal\char34},\text{\ttfamily \char34 Ghana\char34},\text{\ttfamily \char34 Uruguay\char34},\text{\ttfamily \char34 Korea~Republic\char34}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Deste modo, \textit{groups !! 0} corresponde ao grupo A, \textit{groups !! 1} ao grupo B, e assim sucessivamente.
Nesta fase, cada seleção de cada grupo vai defrontar (uma vez) as outras do seu grupo. 

Passam para o ``mata-mata'' as duas seleções que mais pontuarem em cada grupo, obtendo pontos, por cada jogo da fase grupos, da seguinte forma:
\begin{itemize}
\item vitória --- 3 pontos;
\item empate --- 1 ponto;
\item derrota --- 0 pontos.
\end{itemize}
Como se disse, a posição final no grupo irá determinar se uma seleção avança para o ``mata-mata'' e, se avançar, que possíveis jogos terá pela frente, uma vez que a disposição das seleções está desde o início definida para esta última fase, conforme se pode ver na figura \ref{fig:wcup22}.
\begin{figure}[ht]
    \centering
    \includegraphics[scale=0.125]{cp2223t_media/wcup2022.png}
    \caption{O ``mata-mata''}
    \label{fig:wcup22}
\end{figure}

Assim, é necessário calcular os vencedores dos grupos sob uma distribuição probabilística.
Uma vez calculadas as distribuições dos vencedores, é necessário colocá-las nas folhas de uma \ensuremath{{\LTree}} de forma a fazer um \textit{match} com a figura \ref{fig:wcup22}, entrando assim na fase final da competição, o tão esperado ``mata-mata''.
Para avançar nesta fase final da competição (i.e.\ subir na árvore), é preciso ganhar, quem perder é automaticamente eliminado (``mata-mata''). Quando uma seleção vence um jogo, sobe na árvore, quando perde, fica pelo caminho. Isto significa que a seleção vencedora é aquela que vence todos os jogos do ``mata-mata''.

\subsection*{Arquitetura proposta}

A visão composicional da equipa permitiu-lhe perceber desde logo que o problema podia ser dividido, independentemente da versão, probabilística ou não, em duas partes independentes --- a da fase de grupos e a do ``mata-mata''. Assim, duas sub-equipas poderiam trabalhar em paralelo, desde que se garantisse a composicionalidade das partes.
Decidiu-se que os alunos desenvolveriam a parte da fase de grupos e os docentes a do ``mata-mata''.

\subsubsection*{Versão não probabilística}
O resultado final (não probabilístico) é dado pela seguinte função:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{winner}\mathbin{::}\Conid{Team}{}\<[E]%
\\
\>[B]{}\Varid{winner}\mathrel{=}\Varid{wcup}\;\Varid{groups}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{wcup}\mathrel{=}\Varid{knockoutStage}\comp \Varid{groupStage}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A sub-equipa dos docentes já entregou a sua parte:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{knockoutStage}\mathrel{=}\llparenthesis\, \alt{\Varid{id}}{\Varid{koCriteria}}\,\rrparenthesis{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Considere-se agora a proposta do \textit{team leader} da sub-equipa dos alunos para o desenvolvimento da fase de grupos:

\begin{bquote}
{\slshape

Vamos dividir o processo em 3 partes:
\begin{itemize}
\item gerar os jogos,
\item simular os jogos,
\item preparar o ``mata-mata'' gerando a árvore de jogos dessa fase (fig. \ref{fig:wcup22}).
\end{itemize}
Assim:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{groupStage}\mathbin{::}[\mskip1.5mu \Conid{Group}\mskip1.5mu]\to {\LTree}\;\Conid{Team}{}\<[E]%
\\
\>[B]{}\Varid{groupStage}\mathrel{=}\Varid{initKnockoutStage}\comp \Varid{simulateGroupStage}\comp \Varid{genGroupStageMatches}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Comecemos então por definir a função \ensuremath{\Varid{genGroupStageMatches}} que gera os jogos da fase de grupos:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{genGroupStageMatches}\mathbin{::}[\mskip1.5mu \Conid{Group}\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Conid{Match}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{genGroupStageMatches}\mathrel{=}\map \;\Varid{generateMatches}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
onde
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Match}\mathrel{=}(\Conid{Team},\Conid{Team}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Ora, sabemos que nos foi dada a função
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{gsCriteria}\mathbin{::}\Conid{Match}\to \Conid{Maybe}\;\Conid{Team}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que, mediante um certo critério, calcula o resultado de um jogo, retornando \ensuremath{\Conid{Nothing}} em caso de empate, ou a equipa vencedora (sob o construtor \ensuremath{\Conid{Just}}). Assim, precisamos de definir a função
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{simulateGroupStage}\mathbin{::}[\mskip1.5mu [\mskip1.5mu \Conid{Match}\mskip1.5mu]\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Conid{Team}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{simulateGroupStage}\mathrel{=}\map \;(\Varid{groupWinners}\;\Varid{gsCriteria}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que simula a fase de grupos e dá como resultado a lista dos vencedores,
recorrendo à função \ensuremath{\Varid{groupWinners}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{groupWinners}\;\Varid{criteria}\mathrel{=}\Varid{best}\;\mathrm{2}\comp \Varid{consolidate}\comp (\bind \Varid{matchResult}\;\Varid{criteria}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Aqui está apenas em falta a definição da função \ensuremath{\Varid{matchResult}}.

Por fim, teremos a função \ensuremath{\Varid{initKnockoutStage}} que produzirá a \ensuremath{{\LTree}} que a sub-equipa do ``mata-mata'' precisa, com as devidas posições. Esta será a composição de duas funções:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{initKnockoutStage}\mathrel{=}\lanabracket\;\!\Varid{glt}\;\!\ranabracket\comp \Varid{arrangement}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
}
\end{bquote}
Trabalho a fazer:
\begin{enumerate}
\item	Definir uma alternativa à função genérica \ensuremath{\Varid{consolidate}} que seja um
catamorfismo de listas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{consolidate'}\mathbin{::}(\Conid{Eq}\;\Varid{a},\Conid{Num}\;\Varid{b})\Rightarrow [\mskip1.5mu (\Varid{a},\Varid{b})\mskip1.5mu]\to [\mskip1.5mu (\Varid{a},\Varid{b})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{consolidate'}\mathrel{=}\llparenthesis\, \Varid{cgene}\,\rrparenthesis{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\item	Definir a função \ensuremath{\Varid{matchResult}\mathbin{::}(\Conid{Match}\to \Conid{Maybe}\;\Conid{Team})\to \Conid{Match}\to [\mskip1.5mu (\Conid{Team},\Conid{Int})\mskip1.5mu]} que apura os pontos das equipas de um dado jogo.
\item Definir a função genérica \ensuremath{\Varid{pairup}\mathbin{::}\Conid{Eq}\;\Varid{b}\Rightarrow [\mskip1.5mu \Varid{b}\mskip1.5mu]\to [\mskip1.5mu (\Varid{b},\Varid{b})\mskip1.5mu]} em que
	\ensuremath{\Varid{generateMatches}} se baseia.
\item Definir o gene \ensuremath{\Varid{glt}}.
\end{enumerate}

\subsubsection*{Versão probabilística}

Nesta versão, mais realista, \ensuremath{\Varid{gsCriteria}\mathbin{::}\Conid{Match}\to (\Conid{Maybe}\;\Conid{Team})} dá lugar a
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pgsCriteria}\mathbin{::}\Conid{Match}\to \fun{Dist}\;(\Conid{Maybe}\;\Conid{Team}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que dá, para cada jogo, a probabilidade de cada equipa vencer ou haver um empate.
Por exemplo, há \ensuremath{\mathrm{50}\mathbin{\%}} de probabilidades de Portugal empatar com a Inglaterra,
\begin{quote}
\begin{tabbing}\ttfamily
~pgsCriteria\char40{}\char34{}Portugal\char34{}\char44{}\char34{}England\char34{}\char41{}\\
\ttfamily ~~~~~~~~~Nothing~~50\char46{}0\char37{}\\
\ttfamily ~~Just~\char34{}England\char34{}~~26\char46{}7\char37{}\\
\ttfamily ~Just~\char34{}Portugal\char34{}~~23\char46{}3\char37{}
\end{tabbing}
\end{quote}
etc.

O que é \ensuremath{\fun{Dist}}? É o mónade que trata de distribuições probabilísticas e que é descrito no
anexo \ref{sec:probabilities}, página \pageref{sec:probabilities} e seguintes. O que há a fazer? Eis o que diz o vosso \emph{team leader}:

\begin{bquote}
\slshape
O que há a fazer nesta versão é, antes de mais, avaliar qual é o impacto
de \ensuremath{\Varid{gsCriteria}} virar monádica (em \ensuremath{\fun{Dist}}) na arquitetura geral da versão
anterior. Há que reduzir esse impacto ao mínimo, escrevendo-se tão pouco código
quanto possível!
\end{bquote}

Todos relembraram algo que tinham aprendido nas aulas teóricas a respeito
da ``monadificação'' do código: há que reutilizar o código da versão anterior,
monadificando-o.

Para distinguir as duas versões decidiu-se afixar o prefixo `p'  para identificar
uma função que passou a ser monádica.

A sub-equipa dos docentes fez entretanto a monadificação da sua parte:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pwinner}\mathbin{::}\fun{Dist}\;\Conid{Team}{}\<[E]%
\\
\>[B]{}\Varid{pwinner}\mathrel{=}\Varid{pwcup}\;\Varid{groups}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{pwcup}\mathrel{=}\Varid{pknockoutStage}\kcomp\Varid{pgroupStage}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
E entregou ainda a versão probabilística do ``mata-mata'':
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pknockoutStage}\mathrel{=}\Varid{mcataLTree'}\;\alt{\Varid{return}}{\Varid{pkoCriteria}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{mcataLTree'}\;\Varid{g}\mathrel{=}\Varid{k}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Varid{k}\;(\Conid{Leaf}\;\Varid{a})\mathrel{=}\Varid{g1}\;\Varid{a}{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Varid{k}\;(\Conid{Fork}\;(\Varid{x},\Varid{y}))\mathrel{=}\Varid{mmbin}\;\Varid{g2}\;(\Varid{k}\;\Varid{x},\Varid{k}\;\Varid{y}){}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Varid{g1}\mathrel{=}\Varid{g}\comp i_1{}\<[E]%
\\
\>[B]{}\hsindent{9}{}\<[9]%
\>[9]{}\Varid{g2}\mathrel{=}\Varid{g}\comp i_2{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
A sub-equipa dos alunos também já adiantou trabalho,
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pgroupStage}\mathrel{=}\Varid{pinitKnockoutStage}\kcomp\Varid{psimulateGroupStage}\comp \Varid{genGroupStageMatches}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
mas faltam ainda \ensuremath{\Varid{pinitKnockoutStage}} e \ensuremath{\Varid{pgroupWinners}}, esta usada em \ensuremath{\Varid{psimulateGroupStage}},
que é dada em anexo. 

Trabalho a fazer:
\begin{itemize}
\item	Definir as funções que ainda não estão implementadas nesta versão.
\item	\textbf{Valorização}: experimentar com outros critérios de ``ranking'' das equipas.
\end{itemize}

\begin{alert}
\textbf{Importante}: (a) código adicional terá que ser colocado no anexo
\ref{sec:resolucao}, obrigatoriamente; (b) todo o código que é dado não pode
ser alterado.
\end{alert}

\part*{Anexos}

\appendix

\section{Documentação para realizar o trabalho}
\label{sec:documentacao}
Para cumprir de forma integrada os objectivos do trabalho vamos recorrer
a uma técnica de programa\-ção dita
``\litp{literária}'' \cite{Kn92}, cujo princípio base é o seguinte:
%
\begin{quote}\em Um programa e a sua documentação devem coincidir.
\end{quote}
%
Por outras palavras, o código fonte e a documentação de um
programa deverão estar no mesmo ficheiro.

O ficheiro \texttt{cp2223t.pdf} que está a ler é já um exemplo de
\litp{programação literária}: foi gerado a partir do texto fonte
\texttt{cp2223t.lhs}\footnote{O sufixo `lhs' quer dizer
\emph{\lhaskell{literate Haskell}}.} que encontrará no
\MaterialPedagogico\ desta disciplina descompactando o ficheiro
\texttt{cp2223t.zip} e executando:
\begin{Verbatim}[fontsize=\small]
    $ lhs2TeX cp2223t.lhs > cp2223t.tex
    $ pdflatex cp2223t
\end{Verbatim}
em que \href{https://hackage.haskell.org/package/lhs2tex}{\texttt\LhsToTeX} é
um pré-processador que faz ``pretty printing''
de código Haskell em \Latex\ e que deve desde já instalar utilizando o
utiliário \href{https://www.haskell.org/cabal/}{cabal} disponível em \href{https://www.haskell.org}{haskell.org}.

Por outro lado, o mesmo ficheiro \texttt{cp2223t.lhs} é executável e contém
o ``kit'' básico, escrito em \Haskell, para realizar o trabalho. Basta executar
\begin{Verbatim}[fontsize=\small]
    $ ghci cp2223t.lhs
\end{Verbatim}

\noindent Abra o ficheiro \texttt{cp2223t.lhs} no seu editor de texto preferido
e verifique que assim é: todo o texto que se encontra dentro do ambiente
\begin{quote}\small\tt
\text{\ttfamily \char92{}begin\char123{}code\char125{}}
\\ ... \\
\text{\ttfamily \char92{}end\char123{}code\char125{}}
\end{quote}
é seleccionado pelo \GHCi\ para ser executado.

\subsection{Como realizar o trabalho}
Este trabalho teórico-prático deve ser realizado por grupos de 3 (ou 4) alunos.
Os detalhes da avaliação (datas para submissão do relatório e sua defesa
oral) são os que forem publicados na \cp{página da disciplina} na \emph{internet}.

Recomenda-se uma abordagem participativa dos membros do grupo
em todos os exercícios do trabalho, para assim
poderem responder a qualquer questão colocada na
\emph{defesa oral} do relatório.

Em que consiste, então, o \emph{relatório} a que se refere o parágrafo anterior?
É a edição do texto que está a ser lido, preenchendo o anexo \ref{sec:resolucao}
com as respostas. O relatório deverá conter ainda a identificação dos membros
do grupo de trabalho, no local respectivo da folha de rosto.

Para gerar o PDF integral do relatório deve-se ainda correr os comando seguintes,
que actualizam a bibliografia (com \Bibtex) e o índice remissivo (com \Makeindex),
\begin{Verbatim}[fontsize=\small]
    $ bibtex cp2223t.aux
    $ makeindex cp2223t.idx
\end{Verbatim}
e recompilar o texto como acima se indicou.

No anexo \ref{sec:codigo}, disponibiliza-se algum
código \Haskell\ relativo aos problemas apresentados. Esse anexo deverá
ser consultado e analisado à medida que isso for necessário.

\subsection{Como exprimir cálculos e diagramas em LaTeX/lhs2tex}
Como primeiro exemplo, estudar o texto fonte deste trabalho para obter o
efeito:\footnote{Exemplos tirados de \cite{Ol18}.}
\begin{eqnarray*}
\start
     \ensuremath{\Varid{id}\mathrel{=}\conj{\Varid{f}}{\Varid{g}}}
%
\just\equiv{ universal property }
%
        \ensuremath{\begin{lcbr}\p1\comp \Varid{id}\mathrel{=}\Varid{f}\\\p2\comp \Varid{id}\mathrel{=}\Varid{g}\end{lcbr}}
%
\just\equiv{ identity }
%
        \ensuremath{\begin{lcbr}\p1\mathrel{=}\Varid{f}\\\p2\mathrel{=}\Varid{g}\end{lcbr}}
\qed
\end{eqnarray*}

Os diagramas podem ser produzidos recorrendo à \emph{package} \LaTeX\
\href{https://ctan.org/pkg/xymatrix}{xymatrix}, por exemplo:
\begin{eqnarray*}
\xymatrix@C=2cm{
    \ensuremath{\N_0}
           \ar[d]_-{\ensuremath{\llparenthesis\, \Varid{g}\,\rrparenthesis}}
&
    \ensuremath{\mathrm{1}\mathbin{+}\N_0}
           \ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\llparenthesis\, \Varid{g}\,\rrparenthesis}}
           \ar[l]_-{\ensuremath{\mathsf{in}}}
\\
     \ensuremath{\Conid{B}}
&
     \ensuremath{\mathrm{1}\mathbin{+}\Conid{B}}
           \ar[l]^-{\ensuremath{\Varid{g}}}
}
\end{eqnarray*}

\section{Regra prática para a recursividade mútua em \ensuremath{\N_0}}\label{sec:mr}

Nesta disciplina estudou-se como fazer \pd{programação dinâmica} por cálculo,
recorrendo à lei de recursividade mútua.\footnote{Lei (\ref{eq:fokkinga})
em \cite{Ol18}, página \pageref{eq:fokkinga}.}

Para o caso de funções sobre os números naturais (\ensuremath{\N_0}, com functor
\ensuremath{\fun F \;\Conid{X}\mathrel{=}\mathrm{1}\mathbin{+}\Conid{X}}) é fácil derivar-se da lei que foi estudada uma
  \emph{regra de algibeira}
  \label{pg:regra}
que se pode ensinar a programadores que não tenham estudado
\cp{Cálculo de Programas}. Apresenta-se de seguida essa regra, tomando como
exemplo o cálculo do ciclo-\textsf{for} que implementa a função de Fibonacci,
recordar o sistema:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fib}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{fib}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{f}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{f}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{f}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{fib}\;\Varid{n}\mathbin{+}\Varid{f}\;\Varid{n}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Obter-se-á de imediato
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fib'}\mathrel{=}\p1\comp \for{\Varid{loop}}\ {\Varid{init}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{loop}\;(\Varid{fib},\Varid{f})\mathrel{=}(\Varid{f},\Varid{fib}\mathbin{+}\Varid{f}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{init}\mathrel{=}(\mathrm{1},\mathrm{1}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
usando as regras seguintes:
\begin{itemize}
\item O corpo do ciclo \ensuremath{\Varid{loop}} terá tantos argumentos quanto o número de funções
mutuamente recursivas.
\item Para as variáveis escolhem-se os próprios nomes das funções, pela ordem
que se achar conveniente.\footnote{Podem obviamente usar-se outros símbolos,
mas numa primeira leitura dá jeito usarem-se tais nomes.}
\item Para os resultados vão-se buscar as expressões respectivas, retirando
a variável \ensuremath{\Varid{n}}.
\item Em \ensuremath{\Varid{init}} coleccionam-se os resultados dos casos de base das funções,
pela mesma ordem.
\end{itemize}
Mais um exemplo, envolvendo polinómios do segundo grau $ax^2 + b x + c$ em \ensuremath{\N_0}.
Seguindo o método estudado nas aulas\footnote{Secção 3.17 de \cite{Ol18} e tópico
\href{https://www4.di.uminho.pt/~jno/media/cp/}{Recursividade mútua}
nos vídeos de apoio às aulas teóricas.},
de $f\ x = a x^2 + b x + c$ derivam-se duas funções mutuamente recursivas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f}\;\mathrm{0}\mathrel{=}\Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{f}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{f}\;\Varid{n}\mathbin{+}\Varid{k}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{k}\;\mathrm{0}\mathrel{=}\Varid{a}\mathbin{+}\Varid{b}{}\<[E]%
\\
\>[B]{}\Varid{k}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{k}\;\Varid{n}\mathbin{+}\mathrm{2}\;\Varid{a}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Seguindo a regra acima, calcula-se de imediato a seguinte implementação, em Haskell:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{f'}\;\Varid{a}\;\Varid{b}\;\Varid{c}\mathrel{=}\p1\comp \for{\Varid{loop}}\ {\Varid{init}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{loop}\;(\Varid{f},\Varid{k})\mathrel{=}(\Varid{f}\mathbin{+}\Varid{k},\Varid{k}\mathbin{+}\mathrm{2}\mathbin{*}\Varid{a}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{init}\mathrel{=}(\Varid{c},\Varid{a}\mathbin{+}\Varid{b}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{O mónade das distribuições probabilísticas} \label{sec:probabilities}
Mónades são functores com propriedades adicionais que nos permitem obter
efeitos especiais em progra\-mação. Por exemplo, a biblioteca \Probability\
oferece um mónade para abordar problemas de probabilidades. Nesta biblioteca,
o conceito de distribuição estatística é captado pelo tipo
\begin{eqnarray}
     \ensuremath{\mathbf{newtype}\;\fun{Dist}\;\Varid{a}\mathrel{=}\Conid{D}\;\{\mskip1.5mu \Varid{unD}\mathbin{::}[\mskip1.5mu (\Varid{a},\Conid{ProbRep})\mskip1.5mu]\mskip1.5mu\}}
     \label{eq:Dist}
\end{eqnarray}
em que \ensuremath{\Conid{ProbRep}} é um real de \ensuremath{\mathrm{0}} a \ensuremath{\mathrm{1}}, equivalente a uma escala de $0$ a
$100 \%$.

Cada par \ensuremath{(\Varid{a},\Varid{p})} numa distribuição \ensuremath{\Varid{d}\mathbin{::}\fun{Dist}\;\Varid{a}} indica que a probabilidade
de \ensuremath{\Varid{a}} é \ensuremath{\Varid{p}}, devendo ser garantida a propriedade de  que todas as probabilidades
de \ensuremath{\Varid{d}} somam $100\%$.
Por exemplo, a seguinte distribuição de classificações por escalões de $A$ a $E$,
\[
\begin{array}{ll}
A & \rule{2mm}{3pt}\ 2\%\\
B & \rule{12mm}{3pt}\ 12\%\\
C & \rule{29mm}{3pt}\ 29\%\\
D & \rule{35mm}{3pt}\ 35\%\\
E & \rule{22mm}{3pt}\ 22\%\\
\end{array}
\]
será representada pela distribuição
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}d_1 \mathbin{::}\fun{Dist}\;\Conid{Char}{}\<[E]%
\\
\>[B]{}d_1 \mathrel{=}\Conid{D}\;[\mskip1.5mu (\text{\ttfamily 'A'},\mathrm{0.02}),(\text{\ttfamily 'B'},\mathrm{0.12}),(\text{\ttfamily 'C'},\mathrm{0.29}),(\text{\ttfamily 'D'},\mathrm{0.35}),(\text{\ttfamily 'E'},\mathrm{0.22})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
que o \GHCi\ mostrará assim:
\begin{Verbatim}[fontsize=\small]
'D'  35.0%
'C'  29.0%
'E'  22.0%
'B'  12.0%
'A'   2.0%
\end{Verbatim}
É possível definir geradores de distribuições, por exemplo distribuições \emph{uniformes},
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}d_2 \mathrel{=}\Varid{uniform}\;(\Varid{words}\;\text{\ttfamily \char34 Uma~frase~de~cinco~palavras\char34}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
isto é
\begin{Verbatim}[fontsize=\small]
     "Uma"  20.0%
   "cinco"  20.0%
      "de"  20.0%
   "frase"  20.0%
"palavras"  20.0%
\end{Verbatim}
distribuição \emph{normais}, eg.\
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}d_3 \mathrel{=}\Varid{normal}\;[\mskip1.5mu \mathrm{10}\mathinner{\ldotp\ldotp}\mathrm{20}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
etc.\footnote{Para mais detalhes ver o código fonte de \Probability, que é uma adaptação da
biblioteca \PFP\ (``Probabilistic Functional Programming''). Para quem quiser saber mais
recomenda-se a leitura do artigo \cite{EK06}.}
\ensuremath{\fun{Dist}} forma um \textbf{mónade} cuja unidade é \ensuremath{\Varid{return}\;\Varid{a}\mathrel{=}\Conid{D}\;[\mskip1.5mu (\Varid{a},\mathrm{1})\mskip1.5mu]} e cuja composição de Kleisli
é (simplificando a notação)
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}(\Varid{f}\kcomp \Varid{g})\;\Varid{a}\mathrel{=}[\mskip1.5mu (\Varid{y},\Varid{q}\mathbin{*}\Varid{p})\mid (\Varid{x},\Varid{p})\leftarrow \Varid{g}\;\Varid{a},(\Varid{y},\Varid{q})\leftarrow \Varid{f}\;\Varid{x}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
em que \ensuremath{\Varid{g}\mathbin{:}\Conid{A}\to \fun{Dist}\;\mathit B} e \ensuremath{\Varid{f}\mathbin{:}\mathit B\to \fun{Dist}\;\mathit C} são funções \textbf{monádicas} que representam
\emph{computações probabilísticas}.

Este mónade é adequado à resolução de problemas de \emph{probabilidades e estatística} usando programação funcional, de forma elegante e como caso particular da programação monádica.

\section{Código fornecido}\label{sec:codigo}

\subsection*{Problema 1}
Alguns testes para se validar a solução encontrada:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{test}\;\Varid{a}\;\Varid{b}\;\Varid{c}\mathrel{=}\map \;(\Varid{fbl}\;\Varid{a}\;\Varid{b}\;\Varid{c})\;\Varid{x}\equiv \map \;(\Varid{f}\;\Varid{a}\;\Varid{b}\;\Varid{c})\;\Varid{x}\;\mathbf{where}\;\Varid{x}\mathrel{=}[\mskip1.5mu \mathrm{1}\mathinner{\ldotp\ldotp}\mathrm{20}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{test1}\mathrel{=}\Varid{test}\;\mathrm{1}\;\mathrm{2}\;\mathrm{3}{}\<[E]%
\\
\>[B]{}\Varid{test2}\mathrel{=}\Varid{test}\;(\mathbin{-}\mathrm{2})\;\mathrm{1}\;\mathrm{5}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 2}

\textbf{Verificação}: a árvore de tipo \Exp\ gerada por
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{acm\char95 tree}\mathrel{=}\Varid{tax}\;\Varid{acm\char95 ccs}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
deverá verificar as propriedades seguintes:
\begin{itemize}
\item \ensuremath{\Varid{expDepth}\;\Varid{acm\char95 tree}\equiv \mathrm{7}} (profundidade da árvore);
\item \ensuremath{\length \;(\Varid{expOps}\;\Varid{acm\char95 tree})\equiv \mathrm{432}} (número de nós da árvore);
\item \ensuremath{\length \;(\Varid{expLeaves}\;\Varid{acm\char95 tree})\equiv \mathrm{1682}} (número de folhas da árvore).\footnote{Quer dizer, o número total de nodos e folhas é \ensuremath{\mathrm{2114}}, o número de linhas do texto dado.}
\end{itemize}
O resultado final
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{acm\char95 xls}{}\<[10]%
\>[10]{}\mathrel{=}\Varid{post}\;\Varid{acm\char95 tree}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
não deverá ter tamanho inferior ao total de nodos e folhas da árvore.

\subsection*{Problema 3}
Função para visualização em \svg:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{drawSq}\;\Varid{x}\mathrel{=}\Varid{picd''}\;[\mskip1.5mu \Varid{\Conid{Svg}.scale}\;\mathrm{0.44}\;(\mathrm{0},\mathrm{0})\;(\Varid{x}\bind \Varid{sq2svg})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{sq2svg}\;(\Varid{p},\Varid{l})\mathrel{=}(\Varid{color}\;\text{\ttfamily \char34 \#67AB9F\char34}\comp \Varid{polyg})\;[\mskip1.5mu \Varid{p},\Varid{p}\mathbin{.+}(\mathrm{0},\Varid{l}),\Varid{p}\mathbin{.+}(\Varid{l},\Varid{l}),\Varid{p}\mathbin{.+}(\Varid{l},\mathrm{0})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Para efeitos de temporização:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{await}\mathrel{=}\Varid{threadDelay}\;\mathrm{1000000}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 4}
Rankings:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{rankings}\mathrel{=}[\mskip1.5mu {}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Argentina\char34},\mathrm{4.8}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Australia\char34},\mathrm{4.0}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Belgium\char34},\mathrm{5.0}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Brazil\char34},\mathrm{5.0}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Cameroon\char34},\mathrm{4.0}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Canada\char34},\mathrm{4.0}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Costa~Rica\char34},\mathrm{4.1}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Croatia\char34},\mathrm{4.4}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Denmark\char34},\mathrm{4.5}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Ecuador\char34},\mathrm{4.0}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 England\char34},\mathrm{4.7}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 France\char34},\mathrm{4.8}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Germany\char34},\mathrm{4.5}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Ghana\char34},\mathrm{3.8}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Iran\char34},\mathrm{4.2}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Japan\char34},\mathrm{4.2}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Korea~Republic\char34},\mathrm{4.2}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Mexico\char34},\mathrm{4.5}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Morocco\char34},\mathrm{4.2}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Netherlands\char34},\mathrm{4.6}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Poland\char34},\mathrm{4.2}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Portugal\char34},\mathrm{4.6}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Qatar\char34},\mathrm{3.9}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Saudi~Arabia\char34},\mathrm{3.9}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Senegal\char34},\mathrm{4.3}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Serbia\char34},\mathrm{4.2}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Spain\char34},\mathrm{4.7}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Switzerland\char34},\mathrm{4.4}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Tunisia\char34},\mathrm{4.1}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 USA\char34},\mathrm{4.4}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Uruguay\char34},\mathrm{4.5}),{}\<[E]%
\\
\>[B]{}\hsindent{10}{}\<[10]%
\>[10]{}(\text{\ttfamily \char34 Wales\char34},\mathrm{4.3})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Geração dos jogos da fase de grupos:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{generateMatches}\mathrel{=}\Varid{pairup}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Preparação da árvore do ``mata-mata'':
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{arrangement}\mathrel{=}(\bind \Varid{swapTeams})\comp \Varid{chunksOf}\;\mathrm{4}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{swapTeams}\;[\mskip1.5mu [\mskip1.5mu a_1 ,a_2 \mskip1.5mu],[\mskip1.5mu b_1 ,b_2 \mskip1.5mu],[\mskip1.5mu c_1 ,c_2 \mskip1.5mu],[\mskip1.5mu d_1 ,d_2 \mskip1.5mu]\mskip1.5mu]\mathrel{=}[\mskip1.5mu a_1 ,b_2 ,c_1 ,d_2 ,b_1 ,a_2 ,d_1 ,c_2 \mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Função proposta para se obter o \emph{ranking} de cada equipa:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{rank}\;\Varid{x}\mathrel{=}\mathrm{4}\mathbin{**}(\Varid{pap}\;\Varid{rankings}\;\Varid{x}\mathbin{-}\mathrm{3.8}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Critério para a simulação não probabilística dos jogos da fase de grupos:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{56}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{gsCriteria}\mathrel{=}\Varid{s}\comp \conj{\Varid{id}\times\Varid{id}}{\Varid{rank}\times\Varid{rank}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{s}\;((s_1 ,s_2 ),(r_1 ,r_2 ))\mathrel{=}\mathbf{let}\;\Varid{d}\mathrel{=}r_1 \mathbin{-}r_2 \;\mathbf{in}{}\<[E]%
\\
\>[3]{}\hsindent{25}{}\<[28]%
\>[28]{}\mathbf{if}\;\Varid{d}\mathbin{>}\mathrm{0.5}\;\mathbf{then}\;\Conid{Just}\;s_1 {}\<[E]%
\\
\>[28]{}\hsindent{11}{}\<[39]%
\>[39]{}\mathbf{else}\;\mathbf{if}\;\Varid{d}\mathbin{<}\mathbin{-}\mathrm{0.5}\;\mathbf{then}\;\Conid{Just}\;s_2 {}\<[E]%
\\
\>[39]{}\hsindent{17}{}\<[56]%
\>[56]{}\mathbf{else}\;\Conid{Nothing}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Critério para a simulação não probabilística dos jogos do mata-mata:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{koCriteria}\mathrel{=}\Varid{s}\comp \conj{\Varid{id}\times\Varid{id}}{\Varid{rank}\times\Varid{rank}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{s}\;((s_1 ,s_2 ),(r_1 ,r_2 ))\mathrel{=}\mathbf{let}\;\Varid{d}\mathrel{=}r_1 \mathbin{-}r_2 \;\mathbf{in}{}\<[E]%
\\
\>[3]{}\hsindent{25}{}\<[28]%
\>[28]{}\mathbf{if}\;\Varid{d}\equiv \mathrm{0}\;\mathbf{then}\;s_1 {}\<[E]%
\\
\>[28]{}\hsindent{10}{}\<[38]%
\>[38]{}\mathbf{else}\;\mathbf{if}\;\Varid{d}\mathbin{>}\mathrm{0}\;\mathbf{then}\;s_1 \;\mathbf{else}\;s_2 {}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Critério para a simulação probabilística dos jogos da fase de grupos:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pgsCriteria}\mathrel{=}\Varid{s}\comp \conj{\Varid{id}\times\Varid{id}}{\Varid{rank}\times\Varid{rank}}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{s}\;((s_1 ,s_2 ),(r_1 ,r_2 ))\mathrel{=}{}\<[E]%
\\
\>[3]{}\hsindent{3}{}\<[6]%
\>[6]{}\mathbf{if}\;\Varid{abs}\;(r_1 \mathbin{-}r_2 )\mathbin{>}\mathrm{0.5}\;\mathbf{then}\;\mathsf{fmap}\;\Conid{Just}\;(\Varid{pkoCriteria}\;(s_1 ,s_2 ))\;\mathbf{else}\;\Varid{f}\;(s_1 ,s_2 ){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\Varid{f}\mathrel{=}\Conid{D}\comp ((\Conid{Nothing},\mathrm{0.5})\mathbin{:})\comp \map \;(\Conid{Just}\times(\mathbin{/}\mathrm{2}))\comp \Varid{unD}\comp \Varid{pkoCriteria}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Critério para a simulação probabilística dos jogos do mata-mata:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pkoCriteria}\;(e_1 ,e_2 )\mathrel{=}\Conid{D}\;[\mskip1.5mu (e_1 ,\mathrm{1}\mathbin{-}r_2 \mathbin{/}(r_1 \mathbin{+}r_2 )),(e_2 ,\mathrm{1}\mathbin{-}r_1 \mathbin{/}(r_1 \mathbin{+}r_2 ))\mskip1.5mu]\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}r_1 \mathrel{=}\Varid{rank}\;e_1 {}\<[E]%
\\
\>[B]{}\hsindent{5}{}\<[5]%
\>[5]{}r_2 \mathrel{=}\Varid{rank}\;e_2 {}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Versão probabilística da simulação da fase de grupos:\footnote{Faz-se ``trimming'' das distribuições para reduzir o tempo de simulação.}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{31}{@{}>{\hspre}l<{\hspost}@{}}%
\column{47}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{psimulateGroupStage}\mathrel{=}\Varid{trim}\comp {}\<[31]%
\>[31]{}\map \;(\Varid{pgroupWinners}\;\Varid{pgsCriteria}){}\<[E]%
\\
\>[B]{}\Varid{trim}\mathrel{=}\Varid{top}\;\mathrm{5}\comp \Varid{sequence}\comp \map \;(\Varid{filterP}\comp \Varid{norm})\;{}\<[47]%
\>[47]{}\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{filterP}\;(\Conid{D}\;\Varid{x})\mathrel{=}\Conid{D}\;[\mskip1.5mu (\Varid{a},\Varid{p})\mid (\Varid{a},\Varid{p})\leftarrow \Varid{x},\Varid{p}\mathbin{>}\mathrm{0.0001}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{top}\;\Varid{n}\mathrel{=}\Varid{vec2Dist}\comp \Varid{take}\;\Varid{n}\comp \Varid{reverse}\comp \Varid{presort}\;\p2\comp \Varid{unD}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{vec2Dist}\;\Varid{x}\mathrel{=}\Conid{D}\;[\mskip1.5mu (\Varid{a},\Varid{n}\mathbin{/}\Varid{t})\mid (\Varid{a},\Varid{n})\leftarrow \Varid{x}\mskip1.5mu]\;\mathbf{where}\;\Varid{t}\mathrel{=}\Varid{sum}\;(\map \;\p2\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Versão mais eficiente da \ensuremath{\Varid{pwinner}} dada no texto principal, para diminuir o tempo de cada
simulação:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{4}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pwinner}\mathbin{::}\fun{Dist}\;\Conid{Team}{}\<[E]%
\\
\>[B]{}\Varid{pwinner}\mathrel{=}\Varid{mbin}\;\Varid{f}\;\Varid{x}\bind \Varid{pknockoutStage}\;\mathbf{where}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{f}\;(\Varid{x},\Varid{y})\mathrel{=}\Varid{initKnockoutStage}\;(\Varid{x}\mathbin{+\!\!\!+}\Varid{y}){}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{x}\mathrel{=}\conj{\Varid{g}\comp \Varid{take}\;\mathrm{4}}{\Varid{g}\comp \Varid{drop}\;\mathrm{4}}\;\Varid{groups}{}\<[E]%
\\
\>[B]{}\hsindent{4}{}\<[4]%
\>[4]{}\Varid{g}\mathrel{=}\Varid{psimulateGroupStage}\comp \Varid{genGroupStageMatches}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Auxiliares:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{best}\;\Varid{n}\mathrel{=}\map \;\p1\comp \Varid{take}\;\Varid{n}\comp \Varid{reverse}\comp \Varid{presort}\;\p2{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{consolidate}\mathbin{::}(\Conid{Num}\;\Varid{d},\Conid{Eq}\;\Varid{d},\Conid{Eq}\;\Varid{b})\Rightarrow [\mskip1.5mu (\Varid{b},\Varid{d})\mskip1.5mu]\to [\mskip1.5mu (\Varid{b},\Varid{d})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{consolidate}\mathrel{=}\map \;(\Varid{id}\times\Varid{sum})\comp \Varid{collect}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{collect}\mathbin{::}(\Conid{Eq}\;\Varid{a},\Conid{Eq}\;\Varid{b})\Rightarrow [\mskip1.5mu (\Varid{a},\Varid{b})\mskip1.5mu]\to [\mskip1.5mu (\Varid{a},[\mskip1.5mu \Varid{b}\mskip1.5mu])\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{collect}\;\Varid{x}\mathrel{=}\Varid{nub}\;[\mskip1.5mu \Varid{k}\mapsto[\mskip1.5mu \Varid{d'}\mid (\Varid{k'},\Varid{d'})\leftarrow \Varid{x},\Varid{k'}\equiv \Varid{k}\mskip1.5mu]\mid (\Varid{k},\Varid{d})\leftarrow \Varid{x}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Função binária monádica \ensuremath{\Varid{f}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{mmbin}\mathbin{::}\Conid{Monad}\;\Varid{m}\Rightarrow ((\Varid{a},\Varid{b})\to \Varid{m}\;\Varid{c})\to (\Varid{m}\;\Varid{a},\Varid{m}\;\Varid{b})\to \Varid{m}\;\Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{mmbin}\;\Varid{f}\;(\Varid{a},\Varid{b})\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{x}\leftarrow \Varid{a};\Varid{y}\leftarrow \Varid{b};\Varid{f}\;(\Varid{x},\Varid{y})\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Monadificação de uma função binária \ensuremath{\Varid{f}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{mbin}\mathbin{::}\Conid{Monad}\;\Varid{m}\Rightarrow ((\Varid{a},\Varid{b})\to \Varid{c})\to (\Varid{m}\;\Varid{a},\Varid{m}\;\Varid{b})\to \Varid{m}\;\Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{mbin}\mathrel{=}\Varid{mmbin}\comp (\Varid{return}\comp ){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Outras funções que podem ser úteis:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\Varid{f}\mathbin{`\Varid{is}`}\Varid{v})\;\Varid{x}\mathrel{=}(\Varid{f}\;\Varid{x})\equiv \Varid{v}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{rcons}\;(\Varid{x},\Varid{a})\mathrel{=}\Varid{x}\mathbin{+\!\!\!+}[\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%----------------- Soluções dos alunos -----------------------------------------%

\section{Soluções dos alunos}\label{sec:resolucao}
Os alunos devem colocar neste anexo as suas soluções para os exercícios
propostos, de acordo com o ``layout'' que se fornece. Não podem ser
alterados os nomes ou tipos das funções dadas, mas pode ser adicionado
texto, diagramas e/ou outras funções auxiliares que sejam necessárias.

Valoriza-se a escrita de \emph{pouco} código que corresponda a soluções
simples e elegantes.

\subsection*{Problema 1}

Uma vez que a definição de f dada é muito ineficiente, estando associada a uma degradação do tempo de execução
exponencial, comprometemo-nos a otimizar esta definição convertendo-a para um ciclo for.
Com base no que foi descrito anteriormente recorremos à lei de recursividade mútua:

\text{\ttfamily fbl~a~b~c~\char61{}~wrap~\char183{}~for~\char40{}loop~a~b~c\char41{}~initial}

Tendo por base esta regra o grande desafio do problema era calcular o \ensuremath{\Varid{loop}} e o \ensuremath{\Varid{initial}}.

No que diz respeito ao \ensuremath{\Varid{loop}} começamos por definir as três funções auxiliares que iriam representar, f(n), f(n+1) e
f(n+2), sendo elas \ensuremath{\Varid{flb1}}, \ensuremath{\Varid{h}} e \ensuremath{\Varid{k}}, respetivamente. Estas funções estão associadas uma vez que traduzem elementos da 
sequência, assim flb1(n+1) é igual a h(n), h(n+1) é igual a k(n) e finalmente o valor que pretendemos obter de seguida 
(f(n+3)) é equivalente a k(n+1).

Os valores base de \ensuremath{\Varid{flb1}}, \ensuremath{\Varid{h}} e \ensuremath{\Varid{k}}, são 0, 1 e 1, respetivamente.

Segundo a sequência de Fibonacci descrita no problema cada termo sub-sequente aos três primeiros corresponde 
à soma dos três anteriores, estando também sujeito aos coeficientes a, b e c.
Assim de maneira a calcular o próximo valor da sequência (f(n+3) ou k(n+1)) e tal como é apresentado inicialmente
realizamos a seguinte operação:

\text{\ttfamily k~a~b~c~\char40{}n\char43{}1\char41{}~\char61{}~~a~\char42{}~k~a~b~c~n~\char43{}b~\char42{}~h~a~b~c~n~\char43{}~c~\char42{}~fbl1~a~b~c~n}

Após termos todas as funções auxiliares feitas colocamos as mesmas no loop da seguinte maneira:

\text{\ttfamily loop~a~b~c\char40{}\char40{}k\char44{}h\char41{}\char44{}fbl1\char41{}\char61{}\char40{}\char40{}a\char42{}k\char43{}b\char42{}h\char43{}c\char42{}fbl1\char44{}k\char41{}\char44{}h\char41{}}

Deste modo e considerando como initial ((1,1),0) conseguimos otimizar com sucesso a definição de f dada inicialmente.

Funções auxiliares pedidas:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{fbl1}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\mathrm{0}\mathrel{=}\mathrm{0}{}\<[E]%
\\
\>[B]{}\Varid{fbl1}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{h}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{k}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{k}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}{}\<[18]%
\>[18]{}\Varid{a}\mathbin{*}\Varid{k}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{n}\mathbin{+}\Varid{b}\mathbin{*}\Varid{h}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{n}\mathbin{+}\Varid{c}\mathbin{*}\Varid{fbl1}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{h}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\mathrm{0}\mathrel{=}\mathrm{1}{}\<[E]%
\\
\>[B]{}\Varid{h}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;(\Varid{n}\mathbin{+}\mathrm{1})\mathrel{=}\Varid{k}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;\Varid{n}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{loop}\;\Varid{a}\;\Varid{b}\;\Varid{c}\;((\Varid{k},\Varid{h}),\Varid{fbl1})\mathrel{=}((\Varid{a}\mathbin{*}\Varid{k}\mathbin{+}\Varid{b}\mathbin{*}\Varid{h}\mathbin{+}\Varid{c}\mathbin{*}\Varid{fbl1},\Varid{k}),\Varid{h}){}\<[E]%
\\
\>[B]{}\Varid{initial}\mathrel{=}((\mathrm{1},\mathrm{1}),\mathrm{0}){}\<[E]%
\\
\>[B]{}\Varid{wrap}\mathrel{=}\p2{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\newpage

Após finalizarmos a implementação da função pretendida, comparamo-la à função f, para percebermos o quão mais rápida seria.
Este foi o resultado obtido:

\begin{figure}[h!]
  \centering
  \includegraphics[width=0.5\textwidth]{cp2223t_media/tempo.png}
  \caption{Testes de performance}
\end{figure}

\subsection*{Problema 2}

\textbf{1.}

Tendo em conta o diagrama do problema, podemos observar que o \ensuremath{\Varid{gene}} corresponde a uma composição de funções,
que pode ser definida por uma função desconhecida após o \ensuremath{\Varid{out}} das listas.

Sabemos ainda que esta função é definida pelo seguinte diagrama:

\begin{eqnarray*}
\xymatrix{
  S + S \ensuremath{\times} S^*\ar[r]^{\cdots} & S + S \ensuremath{\times} (S^*)^*\\
  &
}
\end{eqnarray*}

Para descobrir a função, seguimos o seguinte raciocínio:

Ao passar a função \ensuremath{\Varid{tax}} à lista $["CSS", "   Documento", "      Reference", "   Cross"]$, esta
deverá devolver a expressão: $$Term "CSS"[Term "Documento" [Var "Reference"], Var "Cross"]$$

Para construir esta expressão através do $in_{Exp}$, conclui-se que este terá de receber um
$$Right("CSS",[Term "Documento" [Var "Reference"], Var "Cross"])$$

Seguindo o mesmo raciocínio, para resultar a expressão acima, é necessário que o functor receba
$$Right ("CSS", [["Documento", "Reference"], ["Cross"]])$$

Concluímos deste modo, que o \ensuremath{\Varid{gene}} ao receber $["CSS", "    Documento", "     Cross"]$ 
terá de devolver $Right ("CSS", [["Documento", "    Reference"], ["Cross"]])$.

Como a função \ensuremath{\Varid{out}} aplicada à lista inicial devolve 
$Right ("CSS", ["    Documento", "        Reference"], ["    Cross"])$, 
a função desconhecida terá que receber o resultado do \ensuremath{\Varid{out}} e devolver

$Right ("CSS", [["Documento", "    Reference"], ["Cross"]])$

Verificamos então que necessitamos de retirar quatro espaços às \textit{strings} 
dos níveis de hierarquia inferior ao \textit{CSS}

\text{\ttfamily map~\char40{}drop~4\char41{}}

Uma vez que as \textit{strings} do nível hierárquico seguinte 
podem ser identificadas pela ausência de um espaço nos prefixos da mesma, 
teremos que as agrupar até ao início de uma \textit{string} 
correspondente ao mesmo nível hierárquico.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{groupByIndentation}\mathbin{::}[\mskip1.5mu \Conid{String}\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Conid{String}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{groupByIndentation}\mathrel{=}\Varid{groupBy}\;(\lambda \Varid{x}\;\Varid{y}\to \Varid{startsWithSpaces}\;\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Onde a função \text{\ttfamily startsWithSpaces} é identificada por
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{startsWithSpaces}\;\Varid{s}\mathrel{=}\Varid{isPrefixOf}\;\text{\ttfamily \char34 ~\char34}\;{}\<[38]%
\>[38]{}\Varid{s}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Deste modo, esta função desconhecida será um funtor de listas que utiliza 
uma função que cumpra os requisitos do parágrafo anterior.
Para tal, definimos o \ensuremath{\Varid{gene}} como sendo 
Gene de \ensuremath{\Varid{tax}}:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{gene}\mathrel{=}\Varid{recList}\;(\Varid{groupByIndentation}\comp \map \;(\Varid{drop}\;\mathrm{4}))\comp \Varid{out}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\textbf{2.}

Decidimos definir a função \ensuremath{\Varid{post}} como um catamorfismo de \textit{Exp}. Para tal, construímos
o seguinte diagrama:

\begin{eqnarray*}
\xymatrix@C = 2cm@R=1cm{
  Exp S S\ar[d]_{\ensuremath{\Varid{post}}} & S + S \ensuremath{\times} (Exp S S)^*\ar[l]_{\ensuremath{\mathsf{in}_{\tiny\ \textit{Exp}}}}\ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{id}\times\Varid{post}}^*}\\
  (S^*)^* & S + S \ensuremath{\times} (S^*)^*\ar[l]^{\ensuremath{\Varid{genePost}}}
}
\end{eqnarray*}

Seguindo o mesmo raciocínio utilizado para a definição da função \ensuremath{\Varid{tax}}, passando o seguinte exemplo

$$Term "CCS"[Term "Gen"[Var "Doc", Var "Cross"]]$$

A função \ensuremath{\Varid{post}} terá que retornar

$$[["CCS"],["CCS","Gen"],["CCS", "Gen","Doc"],["CCS","Gen","Cross"]]$$

Passando o nosso exemplo do \ensuremath{\mathsf{out}_{\tiny\ \textit{Exp}}}, observamos que o resultado obtido é

$$Right ("CCS",[Term "Gen"[Var "Doc", Var "Cross"]])$$

Por outro lado, se fornecermos unicamente \textit{Var "CCS"}, obtemos  \textit{Left "CCS"}.

Visto isto, o \ensuremath{\Varid{gene}} pode ser definido pelo diagrama

\begin{eqnarray*}
\xymatrix@C = 4cm@R=2cm{
  & (S^*)^* &\\
  S\ar[r]_{\ensuremath{i_1}}\ar[ru]^{varToListlist} & S + S \ensuremath{\times} (S^*)^*\ar[u]_{[\ensuremath{\Varid{varToListlist}} , \ensuremath{\Varid{listaFinal}}]} & S \ensuremath{\times} (S^*)^*\ar[l]^{\ensuremath{i_2}}\ar[lu]_{listaFinal}
}
\end{eqnarray*}

No caso do \ensuremath{\Varid{gene}} receber \textit{Left "CCS"}, este apenas terá de retornar \textit{[["CCS"]]}. Para tal definimos a
função

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{varToListlist}\mathbin{::}\Conid{String}\to [\mskip1.5mu [\mskip1.5mu \Conid{String}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{varToListlist}\;\Varid{x}\mathrel{=}\Varid{singl}\;(\Varid{singl}\;\Varid{x}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

recorrendo ao \ensuremath{\Varid{singl}} presente no ficheiro \textit{cp.hs}.

Se o \ensuremath{\Varid{gene}} receber $Right ("CCS",[[["Gen","Doc"]],[["Gen","Cross"]]])$, terá de responder com

$$[["CCS"],["CCS","Gen"],["CCS","Gen","Doc"],["CCS","Gen","Cross"]]$$

Para obter este resultado, definimos então a função 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{listaFinal}\;(\Varid{x},\Varid{y})\mathrel{=}\map \;\overline{\mathsf{conc}}\;(\Varid{singl}\;\Varid{x})\;(\Varid{lidarcomalista}\;\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Onde \text{\ttfamily lidarcomalista} concatena a lista $$[[["Gen","Doc"]],[["Gen","Cross"]]]$$

E mete a lista vazia à cabeça, dando o seguinte resultado 

$$[[],["Gen","Doc"],["Gen","Cross"]]$$

Esta função pode ser definida da seguinte forma

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{lidarcomalista}\;\Varid{y}\mathrel{=}\overline{\Varid{cons}}\;(\Varid{nil}\;\mathrm{1})\;(\Varid{concat}\;\Varid{y}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

A função \text{\ttfamily listaFinal} corresponde a colocar o \textit{"CCS"} dentro de uma lista e
concatenar a todas as listas dentro da lista principal recebida do \text{\ttfamily lidarcomalista}

Deste modo, é fácil de perceber que o \ensuremath{\Varid{genePost}} pode ser definido por um \ensuremath{\alt{\cdot }{\cdot }} de 
ambas as funções. Por sua vez o \ensuremath{\Varid{post}} é definido por um catamorfismo deste gene.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{genePost}\mathrel{=}\alt{\Varid{varToListlist}}{\Varid{listaFinal}}{}\<[E]%
\\
\>[B]{}\Varid{post}\mathrel{=}\llparenthesis\, \Varid{genePost}\,\rrparenthesis_\textit{\tiny Exp}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\subsection*{Problema 3}
\textbf{1.}

Primeiramente, para conseguirmos definir os genes do hilomorfismo \textit{sierpinski}, começamos por desenhar
o diagrama do mesmo para visualizarmos o problema em mãos

\begin{eqnarray*}
\xymatrix@C = 2cm@R=1cm{
  (Square, Int)\ar[rr]^{gsp}\ar[d]_{\ensuremath{\lanabracket\;\!\Varid{gsp}\;\!\ranabracket_\textit{\tiny R}}}&  & Square \ensuremath{\times} (Square, Int)^*\ar[d]^{id \ensuremath{\times\lanabracket\;\!\Varid{gsp}\;\!\ranabracket_\textit{\tiny R}}^*}  \\
  Rose Square\ar@/^1pc/[rr]^{\ensuremath{\Varid{outRose}}}\ar[d]_{\ensuremath{\llparenthesis\, \Varid{gr2l}\,\rrparenthesis_\textit{\tiny R}}} & \cong & Square \ensuremath{\times} (Rose Square)^*\ar@/^1pc/[ll]_{\ensuremath{\Varid{inRose}}}\ar[d]^{id \ensuremath{\times\llparenthesis\, \Varid{gr2l}\,\rrparenthesis_\textit{\tiny R}}^*}\\
  (Square^*)^* &  & Square \ensuremath{\times} Square^*\ar[ll]^{gr2 l} 
}
\end{eqnarray*}

Verificamos então que \ensuremath{\Varid{gsq}} é o gene do anamorfismo \ensuremath{\Varid{squares}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{squares}\mathrel{=}\lanabracket\;\!\Varid{gsq}\;\!\ranabracket_\textit{\tiny R}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{eqnarray*}
\xymatrix@C = 2cm@R=1cm{
  Rose Square & Square \ensuremath{\times} (Rose Square)^*\ar[l]_{\ensuremath{\Varid{inRose}}}\\
  (Square, Int)\ar[u]^{squares^*}\ar[r]_{gsp} & Square \ensuremath{\times} (Square, Int)^*\ar[u]_{id \ensuremath{\times} squares^*} 
}
\end{eqnarray*}

Ao fornecermos $(((0,0),3),1)$ ao \ensuremath{\Varid{gsq}}, este retorna

\small{$$(((1,1),1),[(((0,0),1),0),(((0,1),1),0),(((0,2),1),0),(((1,0),1),0),(((1,2),1),0),(((2,0),1),0)(((2,0),1),0),(((2,2),1),0)])$$}

Isto significa que ao dar um (\ensuremath{\Conid{Square}},\ensuremath{\Conid{Int}}) , é devolvido um par com o quadrado a ser pintado e 
os quadrados da profundidade seguinte.

A função \ensuremath{\Varid{t}}, dado um \ensuremath{\Conid{Square}}, devolve o \ensuremath{\Conid{Square}} a ser pintado e a função \ensuremath{\Varid{modifyTuple}}, 
dado o (\ensuremath{\Conid{Square}},\ensuremath{\Conid{Int}}) devolve os quadrados que não são pintados incrementando a profundidade

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{t}\;((\Varid{a},\Varid{b}),\Varid{c})\mathrel{=}((\Varid{a}\mathbin{+}(\Varid{c}\mathbin{/}\mathrm{3}),\Varid{b}\mathbin{+}(\Varid{c}\mathbin{/}\mathrm{3})),\Varid{c}\mathbin{/}\mathrm{3}){}\<[E]%
\\
\>[B]{}\Varid{modifyTupleaux}\;(((\Varid{x},\Varid{y}),\Varid{l}),\Varid{n})\mathrel{=}(\Varid{t}\;((\Varid{x},\Varid{y}),\Varid{l}),\Varid{n}){}\<[E]%
\\
\>[B]{}\Varid{modifyTuple}\;(((\anonymous ,\anonymous ),\anonymous ),\mathrm{0})\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{modifyTuple}\;(((\Varid{x},\Varid{y}),\Varid{l}),\Varid{n})\mathrel{=}[\mskip1.5mu (((\Varid{x}\mathbin{+}\Varid{a},\Varid{y}\mathbin{+}\Varid{b}),\Varid{l}),\Varid{n}\mathbin{-}\mathrm{1})\mid \Varid{a}\leftarrow [\mskip1.5mu \mathbin{-}\Varid{l},\mathrm{0},\Varid{l}\mskip1.5mu],\Varid{b}\leftarrow [\mskip1.5mu \mathbin{-}\Varid{l},\mathrm{0},\Varid{l}\mskip1.5mu],(\Varid{a},\Varid{b})\not\equiv (\mathrm{0},\mathrm{0})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Por sua vez o \ensuremath{\Varid{gsq}} é definido por um split deste género 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{gsq}\mathrel{=}\conj{\Varid{t}\comp \p1}{\Varid{modifyTuple}\comp \Varid{modifyTupleaux}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Verficamos também que o \ensuremath{\Varid{gr2l}} é o gene do catamorfismo \ensuremath{\Varid{rose2List}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{rose2List}\mathrel{=}\llparenthesis\, \Varid{gr2l}\,\rrparenthesis_\textit{\tiny R}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\begin{eqnarray*}
\xymatrix@C = 2cm@R=1cm{
  (Square^*)^*& Square \ensuremath{\times} Square^*\ar[l]_{\ensuremath{\Varid{gr2l}}}\\ 
  Rose Square\ar[u]^{\ensuremath{\Varid{rose2List}}}\ar[r]_{\ensuremath{\Varid{outRose}}} & Square \ensuremath{\times} (Rose Square)^*\ar[u]_{id \ensuremath{\times\Varid{rose2List}}^*}\\
}
\end{eqnarray*}


O \ensuremath{\Varid{gr2l}} irá receber então o par $(\ensuremath{\Conid{Square}}, (\ensuremath{\Conid{Square}}^*)^*)$ e terá que colocar o \ensuremath{\Conid{Square}} na cabeça de 
todas as listas do segundo parâmetro.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{gr2laux}\;(\Varid{x},\Varid{y})\mathrel{=}\overline{\Varid{cons}}\;(\Varid{x})\;(\Varid{concat}\;\Varid{y}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{gr2l}\mathrel{=}\Varid{gr2laux}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\textbf{3.}

Sabendo que o \ensuremath{\Varid{carpets}} é um anamorfismo, procedemos então à construção do seu diagrama

\begin{eqnarray*}
\xymatrix@C = 2cm@R=1cm{
  ((Square)^*)^* & 1 + (Square)^* \ensuremath{\times} ((Square)^*)^*\ar[l]_{\ensuremath{\mathbf{in}}}\\
  Int\ar[u]^{\ensuremath{\Varid{carpets}}}\ar[r]_{\ensuremath{\Varid{gene}}} & 1 + (Square)^* \ensuremath{\times} Int\ar[u]_{id + id \ensuremath{\times} carpets} 
}
\end{eqnarray*}

Verificamos deste modo que dado um inteiro maior que zero, o \ensuremath{\Varid{geneCarpets}} terá de devolver um par
$(\ensuremath{\Conid{Square}}^*, \ensuremath{\Conid{Int}})$, ou seja, os quadrados devolvidos pelo \ensuremath{\Varid{sierpinski}}. Isto tudo pode ser
definido da seguinte forma:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{profSquare}\;\Varid{n}\mathrel{=}\Varid{sierpinski}\;(((\mathrm{0},\mathrm{0}),\mathrm{32}),\Varid{n}\mathbin{-}\mathrm{1}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{sub}\;\Varid{n}\mathrel{=}\Varid{n}\mathbin{-}\mathrm{1}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{geneCarpetsi1}\mathrel{=}i_1\comp \Varid{bang}{}\<[E]%
\\
\>[B]{}\Varid{geneCarpetsi2}\mathrel{=}i_2\comp \conj{\Varid{profSquare}}{\Varid{sub}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{geneCarpets}\;\Varid{i}\mathrel{=}\mathbf{if}\;\Varid{i}\mathbin{>}\mathrm{0}{}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{}\mathbf{then}\;\Varid{geneCarpetsi2}\;\Varid{i}{}\<[E]%
\\
\>[B]{}\hsindent{20}{}\<[20]%
\>[20]{}\mathbf{else}\;\Varid{geneCarpetsi1}\;\Varid{i}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{carpets}\mathrel{=}\anaList{\Varid{geneCarpets}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Para auxiliar a definção do \ensuremath{\Varid{present}}, definimos a função \ensuremath{\Varid{draw}}, que dado uma lista de quadrados, 
os irá desenhar utilizando o \ensuremath{\Varid{drawSq}} e faz \ensuremath{\Varid{await}} em seguida.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{draw}\;\Varid{s}\mathrel{=}\mathbf{do}\;\{\mskip1.5mu \Varid{p}\leftarrow \Varid{drawSq}\;\Varid{s};\Varid{await}\mskip1.5mu\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Deste modo, o \ensuremath{\Varid{present}} pode ser definido como a aplicação de um \textit{monadic map} a uma 
[[\ensuremath{\Conid{Square}}]]. Para obter o efeito desejado, utilizamos a função \ensuremath{\Varid{reverse'}} (presente no \textit{list.hs}).

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{present}\mathrel{=}\Varid{mmap}\;\Varid{draw}\comp \Varid{reverse'}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsection*{Problema 4}
\subsubsection*{Versão não probabilística}
\textbf{1.}
Começamos por desenhar o diagrama do catamorfismo para termos uma precepção visual do problema em mãos

\begin{eqnarray*}
\xymatrix@C = 2cm@R=1cm{
  (a,b)^*\ar[d]_{\ensuremath{\Varid{consolidate}}'} & 1 + (a,b) \ensuremath{\times} (a,b)^*\ar[l]_{\ensuremath{\Varid{inList}}}\ar[d]^{\ensuremath{\Varid{id}\mathbin{+}\Varid{id}\times\Varid{consolidate}}'}\\
  (a,b)^* & 1 + (a,b) \ensuremath{\times} (a,b)^*\ar[l]^{\ensuremath{\Varid{cgene}}}
}
\end{eqnarray*}

Com isto, conseguimos observar que o \ensuremath{\Varid{cgene}} pode ser definido como

\begin{eqnarray*}
\xymatrix@C = 3cm@R=2cm{
  & (a,b)^* &\\
  1\ar[r]_{\ensuremath{i_1}}\ar[ru]^{\ensuremath{\Varid{nil}}} & 1 + (a,b) \ensuremath{\times} (a,b)^*\ar[u]_{[\ensuremath{\Varid{nil}},\ensuremath{\Varid{somaPontos}}]} & (a,b) \ensuremath{\times} (a,b)^*\ar[l]^{\ensuremath{i_2}}\ar[lu]_{\ensuremath{\Varid{somaPontos}}}
}
\end{eqnarray*}

A função \text{\ttfamily somaPontos}, caso a equipa já esteja na lista, apenas lhe aumenta os pontos. Caso contrário,
é adicionada à lista com recurso à função \text{\ttfamily addTupleToList}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addTupleToList}\;(\Varid{c},\Varid{n})\;\Varid{lst}\mathrel{=}\map \;(\lambda (\Varid{x},\Varid{y})\to \mathbf{if}\;\Varid{x}\equiv \Varid{c}\;\mathbf{then}\;(\Varid{x},\Varid{y}\mathbin{+}\Varid{n})\;\mathbf{else}\;(\Varid{x},\Varid{y}))\;\Varid{lst}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{somaPontos}\;(\Varid{c},\Varid{p})\;\Varid{lst}\mathrel{=}\mathbf{if}\;\Varid{any}\;(\lambda (\Varid{x},\Varid{y})\to \Varid{x}\equiv \Varid{c})\;\Varid{lst}\;\mathbf{then}\;\Varid{addTupleToList}\;(\Varid{c},\Varid{p})\;\Varid{lst}\;\mathbf{else}\;(\Varid{c},\Varid{p})\mathbin{:}\Varid{lst}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Deste modo, o gene de \ensuremath{\Varid{consolidate'}} fica definido como

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{cgene}\mathbin{::}(\Conid{Eq}\;\Varid{a},\Conid{Num}\;\Varid{b})\Rightarrow ()+((\Varid{a},\Varid{b}),[\mskip1.5mu (\Varid{a},\Varid{b})\mskip1.5mu])\to [\mskip1.5mu (\Varid{a},\Varid{b})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{cgene}\mathrel{=}\alt{\Varid{nil}}{\uncurry{\Varid{somaPontos}}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\textbf{3.}

Geração dos jogos da fase de grupos:

A função \ensuremath{\Varid{pairup}} trata de agrupar as equipas em partidas, de maneira a que estas não se encontrem 
mais que uma vez.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pairup}\;\Varid{equipas}\mathrel{=}\Varid{pair}\;\Varid{equipas}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathbf{where}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{pair}\;[\mskip1.5mu \mskip1.5mu]\;\anonymous \mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\Varid{pair}\;(\Varid{e}\mathbin{:}\Varid{es})\;\Varid{sorteadas}\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{let}\;\Varid{possiveis}\mathrel{=}\Varid{sort}\mathbin{\$}\Varid{filter}\;(\lambda \Varid{x}\to \Varid{x}\not\equiv \Varid{e}\mathrel{\wedge}\neg \;(\Varid{x}\in \Varid{sorteadas}))\;\Varid{es}{}\<[E]%
\\
\>[5]{}\hsindent{2}{}\<[7]%
\>[7]{}\mathbf{in}\;[\mskip1.5mu (\Varid{e},\Varid{x})\mid \Varid{x}\leftarrow \Varid{possiveis}\mskip1.5mu]\mathbin{+\!\!\!+}\Varid{pair}\;\Varid{es}\;(\Varid{e}\mathbin{:}\Varid{sorteadas}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\newpage

\textbf{2.}

Para nos auxiliar a definir a função \ensuremath{\Varid{matchResult}}, desenhamos o seguinte diagrama

\begin{eqnarray*}
\xymatrix@C = 2cm@R=1cm{
  & [(Team, Int)] &\\
  maybe & maybe \ensuremath{\times} match\ar[u]_{pontos}\ar[l]_{\ensuremath{\p1}}\ar[r]^{\ensuremath{\p2}} & match\\
  f \ensuremath{\times} match\ar[u]_{ap} & (f \ensuremath{\times} match) \ensuremath{\times} match\ar[r]_{\ensuremath{\p2}}\ar[l]^{\ensuremath{\p1}}\ar[u]_{ap \ensuremath{\times} id} & match\ar[u]_{id}\\
  & f \ensuremath{\times} (match \ensuremath{\times} match)\ar[u]_{assocl} &\\
  & f \ensuremath{\times} match\ar[u]_{id \ensuremath{\times} dup} &
}
\end{eqnarray*}

\text{\ttfamily f~\char61{}~\char40{}Match~\char45{}\char62{}~Maybe~Team\char41{}}

Decidimos duplicar \ensuremath{\Conid{Match}}, uma vez que a função \ensuremath{\Varid{pontos}},

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pontos}\;(\Conid{Nothing},(\Varid{eq1},\Varid{eq2}))\mathrel{=}[\mskip1.5mu (\Varid{eq1},\mathrm{1}),(\Varid{eq2},\mathrm{1})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{pontos}\;(\Conid{Just}\;\Varid{eq},\Varid{m})\mathrel{=}[\mskip1.5mu (\Varid{eq},\mathrm{3})\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

em caso de empate (\ensuremath{\Conid{Nothing}}), necessita de saber quais foram as equipas que empataram.

Deste modo, a função \ensuremath{\Varid{matchResult}} fica definida como 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{matchResult}\mathbin{::}(\Conid{Match}\to \Conid{Maybe}\;\Conid{Team})\to \Conid{Match}\to [\mskip1.5mu (\Conid{Team},\Conid{Int})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{matchResult}\mathrel{=}\overline{\Varid{pontos}\comp (\Varid{ap}\times\Varid{id})\comp \Varid{assocl}\comp (\Varid{id}\times\Varid{\Conid{Cp}.dup})}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\textbf{4.}

Desenhamos também o gene do anamorfismo ao qual o \ensuremath{\Varid{glt}} pertence

\begin{eqnarray*}
\xymatrix@C = 3cm@R=1cm{
  \ensuremath{{\LTree}\;\Conid{Team}} & Team + \ensuremath{{\LTree}\;\Conid{Team}\times{\LTree}\;\Conid{Team}}\ar[l]_{\ensuremath{\mathsf{in}_{\tiny\ \textit{LTree}}}}\\
  Team^*\ar[u]^{\ensuremath{\lanabracket\;\!\Varid{glt}\;\!\ranabracket}}\ar[r]_{glt} & Team + Team^* \ensuremath{\times} Team^*\ar[u]_{id + \ensuremath{\lanabracket\;\!\Varid{glt}\;\!\ranabracket\times\lanabracket\;\!\Varid{glt}\;\!\ranabracket}} 
}
\end{eqnarray*}

Caso a lista de \ensuremath{\Conid{Team}} tenha mais que um elemento, o gene terá de a dividir em duas listas.
Para tal, utilizamos a função \ensuremath{\Varid{dividir}} 

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{dividir}\;\Varid{lista}\mathrel{=}\Varid{splitAt}\;(\length \;\Varid{lista}\mathbin{\Varid{`div`}}\mathrm{2})\;\Varid{lista}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Caso só tenha um elemento, apenas terá de retornar a \ensuremath{\Conid{Team}}. Para isso, utilizamos a função 
\ensuremath{\Varid{matchFromArr}}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{matchFromArr}\;\Varid{l}\mathrel{=}(\Varid{l}\mathbin{!!}\mathrm{0}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Para testar a condição de se a lista tem apenas um elemento, e aplicar a sua função correspondente,
usamos o \textbf{Condicional de McCarthy}, definido no ficheiro \textit{Cp.hs}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{finalei1}\mathrel{=}i_1\comp \Varid{matchFromArr}{}\<[E]%
\\
\>[B]{}\Varid{finalei2}\mathrel{=}i_2\comp \Varid{dividir}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{maiorque1}\;\Varid{lista}\mathrel{=}(\length \;\Varid{lista})\mathbin{>}\mathrm{1}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{glt}\mathrel{=}\mcond{\Varid{maiorque1}}{\Varid{finalei2}}{\Varid{finalei1}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\subsubsection*{Versão probabilística}

A função \ensuremath{\Varid{pinitKnockoutStage}} tem que devolver o mesmo resultado que a função \ensuremath{\Varid{initKnockoutStage}} mas 
dentro de um \ensuremath{\Varid{monad}}. Para tal, após a execução de \ensuremath{\Varid{initKnockoutStage}}, utilizamos a função \ensuremath{\Varid{return}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pinitKnockoutStage}\mathrel{=}\Varid{return}\comp \Varid{initKnockoutStage}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Para definir a função \ensuremath{\Varid{pgroupWinners}}, aplicamos a função \ensuremath{\Varid{pmatchResult}} a todas as partidas do grupo.
De seguida, para criar as combinações de todos os resultados possíveis, utilizamos a função \ensuremath{\Varid{sequence}}
e "retiramos os valores da caixa" com o \ensuremath{\Varid{unD}}. Para cada uma das combinações, retiramos os dois 
primeiros do grupo e preservamos a probabilidade através do \text{\ttfamily map~\char40{}\char40{}best~2~\char46{}~consolidate\char39{}~\char46{}~concat\char41{}~\char62{}\char60{}~id\char41{}}.
Por fim, volta-se a "colocar dentro da caixa" através da função \ensuremath{\Conid{D}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pgroupWinners}\mathbin{::}(\Conid{Match}\to \fun{Dist}\;(\Conid{Maybe}\;\Conid{Team}))\to [\mskip1.5mu \Conid{Match}\mskip1.5mu]\to \fun{Dist}\;[\mskip1.5mu \Conid{Team}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{pgroupWinners}\;\Varid{a}\;\Varid{b}\mathrel{=}(\Conid{D}\comp (\map \;((\Varid{best}\;\mathrm{2}\comp \Varid{consolidate'}\comp \Varid{concat})\times\Varid{id}))\comp (\Varid{unD}\comp \Varid{sequence})\comp (\map \;(\Varid{pmatchResult}\;\Varid{a})))\;\Varid{b}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Para definir o \ensuremath{\Varid{pmatchResult}}, desenhamos o seguinte diagrama, semelhante ao \ensuremath{\Varid{matchResult}}

\begin{eqnarray*}
\xymatrix@C = 2cm@R=1cm{
  & \ensuremath{\fun{Dist}\;[\mskip1.5mu (\Conid{Team},\Conid{Int})\mskip1.5mu]} &\\
  & [((\ensuremath{\Conid{Maybe}\;\Conid{Team}}, \ensuremath{\Conid{Match}}),ProbRep)]\ar[u]_{\ensuremath{\Conid{D}\comp (\map \;(\Varid{pontos}\times\Varid{id})})}&\\
  & [\ensuremath{\Conid{Maybe}\;\Conid{Team},\Conid{ProbRep}}] \ensuremath{\times} \ensuremath{\Conid{Match}}\ar[u]_{\ensuremath{\Varid{formatResult}}}&\\
  \ensuremath{\fun{Dist}\;\Varid{maybe}\;\Conid{Team}} & \ensuremath{\fun{Dist}\;\Varid{maybe}\;\Conid{Team}} \ensuremath{\times} match\ar[u]_{\ensuremath{\Varid{unD}\times\Varid{id}}}\ar[l]_{\ensuremath{\p1}}\ar[r]^{\ensuremath{\p2}} & match\\
  f \ensuremath{\times} match\ar[u]_{ap} & (f \ensuremath{\times} match) \ensuremath{\times} match\ar[r]_{\ensuremath{\p2}}\ar[l]^{\ensuremath{\p1}}\ar[u]_{ap \ensuremath{\times} id} & match\ar[u]_{id}\\
  & f \ensuremath{\times} (match \ensuremath{\times} match)\ar[u]_{assocl} &\\
  & f \ensuremath{\times} match\ar[u]_{id \ensuremath{\times} dup} &
}
\end{eqnarray*}

\text{\ttfamily f~\char61{}~\char40{}Match~\char45{}\char62{}~Dist~Maybe~Team\char41{}}

Neste caso, a aplicação da função recebida, em vez de retornar um \ensuremath{\Conid{Maybe}\;\Conid{Team}}, retorna um \ensuremath{\fun{Dist}\;\Conid{Maybe}\;\Conid{Team}}.
Deste modo, para trabalhar com este resultado, devemos "retirar da caixa", utilizando o \ensuremath{\Varid{unD}}.
Iremos obter assim, um tuplo com uma lista de \ensuremath{\fun{Dist}\;\Conid{Maybe}\;\Conid{Team}}. Para podermos aplicar a função \ensuremath{\Varid{pontos}} 
já criada, tivemos de emparelhar todas estas possibilidades com a \ensuremath{\Conid{Match}}. Para tal, utilizamos
a função

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{formatResult}\;(\Varid{possibilidades},\Varid{resultado})\mathrel{=}\map \;(\lambda (\Varid{res},\Varid{prob})\to ((\Varid{res},\Varid{resultado}),\Varid{prob}))\;\Varid{possibilidades}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Uma vez mapeados os pontos, voltamos a colocar o resultado "dentro da caixa" com a função \ensuremath{\Conid{D}}, 
resultando assim, na função

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{pmatchResult}\mathbin{::}(\Conid{Match}\to \fun{Dist}\;(\Conid{Maybe}\;\Conid{Team}))\to \Conid{Match}\to \fun{Dist}\;[\mskip1.5mu (\Conid{Team},\Conid{Int})\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{pmatchResult}\mathrel{=}\overline{\Conid{D}\comp (\map \;(\Varid{pontos}\times\Varid{id}))\comp \Varid{formatResult}\comp (\Varid{unD}\times\Varid{id})\comp (\Varid{ap}\times\Varid{id})\comp \Varid{assocl}\comp (\Varid{id}\times\Varid{\Conid{Cp}.dup})}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%----------------- Índice remissivo (exige makeindex) -------------------------%

\printindex

%----------------- Bibliografia (exige bibtex) --------------------------------%

\bibliographystyle{plain}
\bibliography{cp2223t}

%----------------- Fim do documento -------------------------------------------%

\end{document}
